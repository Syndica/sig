//! Generates the `src/zksdk/range_proof/table.zig` with precomputed G and H generator points.
const std = @import("std");
const Ristretto255 = std.crypto.ecc.Ristretto255;
const Shake256 = std.crypto.hash.sha3.Shake256;

pub const GeneratorsChain = struct {
    shake: Shake256,

    pub fn init(comptime label: []const u8) GeneratorsChain {
        var shake = Shake256.init(.{});
        shake.update("GeneratorsChain");
        shake.update(label);
        return .{ .shake = shake };
    }

    pub fn next(self: *GeneratorsChain) Ristretto255 {
        var bytes: [64]u8 = undefined;
        self.shake.squeeze(&bytes);
        return Ristretto255.fromUniform(bytes);
    }
};

pub fn main() !void {
    var stdout_buffer: [4096]u8 = undefined;
    var stdout_writer = std.fs.File.stdout().writer(&stdout_buffer);
    const writer = &stdout_writer.interface;
    try writer.writeAll(
        \\//! DO NOT MODIFY: File generated by generator_chain.zig
        \\
        \\const std = @import("std");
        \\const Ristretto255 = std.crypto.ecc.Ristretto255;
        \\
    );

    try writeChain("G", writer);
    try writeChain("H", writer);

    try writer.flush();
}

fn writeChain(comptime name: []const u8, writer: anytype) !void {
    try writer.print(
        \\pub const {s}: [256]Ristretto255 = .{{
        \\
    , .{name});

    var generator = GeneratorsChain.init(name);
    for (0..256) |_| {
        const next = generator.next();

        try writer.writeAll("     .{ .p = .{ .x = ");
        try printPoint(next.p.x, writer);
        try writer.writeAll(", .y = ");
        try printPoint(next.p.y, writer);
        try writer.writeAll(", .z = ");
        try printPoint(next.p.z, writer);
        try writer.writeAll(", .t = ");
        try printPoint(next.p.t, writer);

        try writer.writeAll(" }},\n");
    }

    try writer.writeAll("};\n");
}

fn printPoint(p: Ristretto255.Curve.Fe, writer: anytype) !void {
    try writer.print(".{{ .limbs = .{d} }}", .{p.limbs});
}
