//! Generates the feature set ID constant.

const std = @import("std");
const base58 = @import("base58");

const ZonInfo = struct {
    name: [:0]const u8,
    pubkey: [:0]const u8,
    activated_on_all_clusters: bool = false,
    reverted: bool = false,
};

const PUBKEY_SIZE = 32;
const BASE58_ENDEC = base58.Table.BITCOIN;

pub fn main() !void {
    var dba_state: std.heap.DebugAllocator(.{}) = .init;
    defer _ = dba_state.deinit();
    const gpa = dba_state.allocator();

    const argv = try std.process.argsAlloc(gpa);
    defer std.process.argsFree(gpa, argv);

    if (argv.len == 0) return error.EmptyArgv;
    const args = argv[1..];

    if (args.len == 0) return error.MissingOutputFileNameArg;
    const output_file_path = args[0];

    const features: []const ZonInfo = @import("features");

    // Collect all pubkeys
    var pubkeys: [features.len][PUBKEY_SIZE]u8 = undefined;
    for (&pubkeys, features) |*pubkey, feature| {
        var decoded_buf: [base58.decodedMaxSize(base58.encodedMaxSize(pubkey.len))]u8 = undefined;
        const decoded_len = BASE58_ENDEC.decode(&decoded_buf, feature.pubkey) catch |err| {
            std.log.err(
                "Failed to decode pubkey '{s}' for feature '{s}': {s}",
                .{ feature.pubkey, feature.name, @errorName(err) },
            );
            return error.BadPubkey;
        };
        const decoded = decoded_buf[0..decoded_len];
        if (decoded.len != pubkey.len) {
            std.log.err(
                (
                    \\Failed to decode pubkey '{s}' for feature '{s}': invalid length '{d}' when decoded (expected length {d}).
                    \\Decoded result: '{f}'.
                ),
                .{
                    feature.pubkey,
                    feature.name,
                    decoded_len,
                    pubkey.len,
                    std.zig.fmtString(decoded),
                },
            );
            return error.BadPubkey;
        }
        pubkey.* = decoded[0..pubkey.len].*;
    }

    // Sort pubkeys lexicographically
    std.mem.sort([PUBKEY_SIZE]u8, &pubkeys, {}, struct {
        fn lessThan(_: void, a: [PUBKEY_SIZE]u8, b: [PUBKEY_SIZE]u8) bool {
            return std.mem.order(u8, &a, &b) == .lt;
        }
    }.lessThan);

    // Hash all pubkeys
    var hasher = std.crypto.hash.sha2.Sha256.init(.{});
    for (pubkeys) |pk| {
        hasher.update(&pk);
    }
    const feature_set_id = std.mem.readInt(
        u32,
        hasher.finalResult()[0..4],
        .little,
    );

    const output_file = try std.fs.cwd().createFile(output_file_path, .{});
    defer output_file.close();

    var output_buf: [4096]u8 = undefined;
    var output_fw = output_file.writer(&output_buf);
    const output_w = &output_fw.interface;
    try output_w.print(
        \\//! DO NOT MODIFY: File generated by gen_feature_set_id.zig
        \\//!
        \\//! The feature set identifier - first 4 bytes of SHA256 hash of all known feature pubkeys (sorted).
        \\//! This is used for client compatibility checks.
        \\//!
        \\//! [agave] https://github.com/anza-xyz/agave/blob/01159e4643e1d8ee86d1ed0e58ea463b338d563f/feature-set/src/lib.rs#L2318
        \\
        \\pub const FEATURE_SET_ID: u32 = {d};
        \\
    , .{feature_set_id});
    try output_w.flush();
}
