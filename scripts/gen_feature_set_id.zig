//! Generates the feature set ID constant.

const std = @import("std");
const base58 = @import("base58");

const ZonInfo = struct {
    name: [:0]const u8,
    pubkey: [:0]const u8,
    activated_on_all_clusters: bool = false,
    reverted: bool = false,
};

const PUBKEY_SIZE = 32;
const BASE58_ENDEC = base58.Table.BITCOIN;

fn parseBase58(str: []const u8) [PUBKEY_SIZE]u8 {
    var result: [PUBKEY_SIZE]u8 = undefined;
    const len = BASE58_ENDEC.decode(&result, str) catch unreachable;
    std.debug.assert(len == PUBKEY_SIZE);
    return result;
}

pub fn main() !void {
    const features: []const ZonInfo = @import("features");

    // Collect all pubkeys
    var pubkeys: [features.len][PUBKEY_SIZE]u8 = undefined;
    for (&pubkeys, features) |*pubkey, feature| {
        pubkey.* = parseBase58(feature.pubkey);
    }

    // Sort pubkeys lexicographically
    std.mem.sort([PUBKEY_SIZE]u8, &pubkeys, {}, struct {
        fn lessThan(_: void, a: [PUBKEY_SIZE]u8, b: [PUBKEY_SIZE]u8) bool {
            return std.mem.order(u8, &a, &b) == .lt;
        }
    }.lessThan);

    // Hash all pubkeys
    var hasher = std.crypto.hash.sha2.Sha256.init(.{});
    for (pubkeys) |pk| {
        hasher.update(&pk);
    }
    const feature_set_id = std.mem.readInt(
        u32,
        hasher.finalResult()[0..4],
        .little,
    );

    const writer = std.io.getStdOut().writer();
    try writer.print(
        \\//! DO NOT MODIFY: File generated by gen_feature_set_id.zig
        \\//!
        \\//! The feature set identifier - first 4 bytes of SHA256 hash of all known feature pubkeys (sorted).
        \\//! This is used for client compatibility checks.
        \\//!
        \\//! [agave] https://github.com/anza-xyz/agave/blob/01159e4643e1d8ee86d1ed0e58ea463b338d563f/feature-set/src/lib.rs#L2318
        \\
        \\pub const FEATURE_SET_ID: u32 = {d};
        \\
    , .{feature_set_id});
}
