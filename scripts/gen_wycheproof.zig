const std = @import("std");

const Inputs = struct {
    algorithm: []const u8,
    numberOfTests: u32,
    testGroups: []const Group,

    const Group = struct {
        type: []const u8,
        publicKey: PublicKey,
        tests: []const Test,

        const PublicKey = struct {
            keySize: u32,
            pk: []const u8,
        };

        const Test = struct {
            tcId: u32,
            comment: []const u8,

            msg: []const u8,
            sig: []const u8,

            result: []const u8,
        };
    };
};

pub fn main() !void {
    const allocator = std.heap.smp_allocator;

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len != 3) @panic("gen_wycheproof [path to test case json] [path to output zig]");

    const proof_path = args[1];
    const output_path = args[2];

    const contents = try std.fs.cwd().readFileAlloc(allocator, proof_path, 1 * 1024 * 1024);
    defer allocator.free(contents);

    const parsed: Inputs = try std.json.parseFromSliceLeaky(
        Inputs,
        allocator,
        contents,
        .{ .ignore_unknown_fields = true },
    );

    const output_file = try std.fs.cwd().createFile(output_path, .{});
    defer output_file.close();
    const output = output_file.writer();

    try output.print(
        \\//! DO NOT EDIT! File generated by `gen_wycheproof.zig`.
        \\//! algorithm: {s}
        \\//! numberOfTests: {d}
        \\
    , .{ parsed.algorithm, parsed.numberOfTests });

    try output.writeAll(
        \\
        \\const Group = struct {
        \\    pubkey: []const u8,
        \\    cases: []const Case,
        \\
        \\    const Case = struct {
        \\        msg: []const u8,
        \\        sig: []const u8,
        \\        expected: enum { valid, invalid },
        \\    };
        \\};
        \\
        \\pub const groups: []const Group = &.{
        \\
    );

    for (parsed.testGroups) |group| {
        try output.print(
            \\    .{{
            \\        .pubkey = "{s}",
            \\        .cases = &.{{
            \\
        , .{group.publicKey.pk});

        for (group.tests) |case| {
            if (case.comment.len != 0) try output.print(
                \\            // {s}
                \\
            , .{std.mem.trimRight(u8, case.comment, &.{' '})});

            const expected = if (std.mem.eql(u8, case.result, "invalid"))
                "invalid"
            else if (std.mem.eql(u8, case.result, "valid"))
                "valid"
            else
                std.debug.panic("unknown result: '{s}'", .{case.result});

            try output.print(
                \\            .{{ .msg = "{s}", .sig = "{s}", .expected = .{s} }},
                \\
            , .{
                case.msg, case.sig, expected,
            });
        }

        try output.writeAll(
            \\        },
            \\    },
            \\
        );
    }

    try output.writeAll(
        \\};
        \\
    );
}
